package main

import (
	"fmt"
	"os"
	"os/signal"
	"time"

	"github.com/dylandreimerink/gobpfld"
	"github.com/dylandreimerink/gobpfld/bpftypes"
	"github.com/dylandreimerink/gobpfld/ebpf"
	"golang.org/x/sys/unix"
)

// This example command executes the same program as xdp_stats which is basic03-map-counter from
// xdp-tutorial. https://github.com/xdp-project/xdp-tutorial/tree/master/basic03-map-counter
// However, this example demonstrates manually recreating the program from eBPF instructions which
// have been annotated as a bonus lesson in eBPF instructions.
// The same output can be generated by a program using gobpflb to generate dynamic eBPF programs

func main() {
	program := &gobpfld.BPFProgram{
		Name:    gobpfld.MustNewObjName("xdp_stats1"),
		Licence: "GPL",
		Maps: map[string]gobpfld.BPFMap{
			"xdp_stats_map": &gobpfld.BPFGenericMap{
				AbstractMap: gobpfld.AbstractMap{
					Name: gobpfld.MustNewObjName("xdp_stats_map"),
					Definition: gobpfld.BPFMapDef{
						Type:       bpftypes.BPF_MAP_TYPE_ARRAY,
						KeySize:    4, // SizeOf(uint32)
						ValueSize:  8, // SizeOf(uint64)
						MaxEntries: 5,
					},
				},
			},
		},
		MapFDLocations: map[string][]uint64{
			"xdp_stats_map": {
				// LoadConstant64bit is the 5th instruction in this program. So the first byte of the
				// 5th instruction is the width of a instruction * 4 to skip the first 4 instructions
				uint64(ebpf.BPFInstSize) * 4,
			},
		},
		Instructions: ebpf.MustEncode([]ebpf.Instruction{
			////
			// __u32 key = XDP_PASS;
			////
			&ebpf.Mov64{ // r1 = 2
				Dest: ebpf.BPF_REG_1,
				Val:  ebpf.XDP_PASS,
			},
			&ebpf.StoreMemoryRegister{ // *(u32 *)(r10 - 4) = r1
				Size:   ebpf.BPF_W,      // 32bits
				Dest:   ebpf.BPF_REG_10, // R10 = Frame pointer(end of stack)
				Offset: -4,              // 4x8 = 32
				Src:    ebpf.BPF_REG_1,
			},

			////
			// rec = bpf_map_lookup_elem(&xdp_stats_map, &key);
			////
			&ebpf.Mov64Register{ // r2 = r10
				Dest: ebpf.BPF_REG_2,
				Src:  ebpf.BPF_REG_10,
			},
			// make R2 a pointer to key, aka &key
			&ebpf.Add64{ // r2 += -4
				Dest: ebpf.BPF_REG_2,
				Val:  -4,
			},
			// The constant value to be loaded here will be inserted by the loader
			//  it will become a pointer to the map, aka &xdp_stats_map
			&ebpf.LoadConstant64bit{ // r1 = 0 ll
				Dest: ebpf.BPF_REG_1,
			},
			&ebpf.Nop{}, // Nop is a dummy since LoadConstant64bit consumes 2 instructions to fit 64bits
			// The actual function call which takes R1 and R2 as arguments and uses R0 as return value
			//  where R1 is the pointer to the map in which the lookup should occur
			//  and where R2 is the pointer to the key to use
			//  R0 will become a pointer to the value
			&ebpf.Call{ // call 1
				Function: 1, // 1 = bpf_map_lookup_elem
			},

			////
			// if (!rec) return XDP_ABORTED;
			////
			&ebpf.Mov64{ // r1 = 0
				Dest: ebpf.BPF_REG_1,
				Val:  ebpf.XDP_ABORTED, // XDP_ABORTED = 0
			},
			// check if the return value is a null pointer, aka: if (!rec)
			&ebpf.JumpEqual{ // if r0 == 0: goto pc+3 <LBL0>
				Dest:   ebpf.BPF_REG_0,
				Offset: 3, //
				Value:  0,
			},

			////
			// lock_xadd(&rec->rx_packets, 1);
			////
			&ebpf.Mov64{ // r1 = 1
				Dest: ebpf.BPF_REG_1,
				Val:  1,
			},
			&ebpf.AtomicAdd{ // lock *(u64 *)(r0 + 0) += r1
				Size: ebpf.BPF_DW,
				Dest: ebpf.BPF_REG_0, // R0 contains the pointer to the value in the map
				Src:  ebpf.BPF_REG_1,
			},

			////
			// return XDP_PASS;
			////
			&ebpf.Mov64{ // r1 = 2
				Dest: ebpf.BPF_REG_1,
				Val:  ebpf.XDP_PASS, // XDP_PASS = 2
			},

			////
			// Label LBL0, target of JumpEqual
			////
			&ebpf.Mov64Register{ // r0 = r1
				Dest: ebpf.BPF_REG_0, // R0 is the return value of this program
				Src:  ebpf.BPF_REG_1, // R1 is XDP_PASS or XDP_ABORTED depending on branching
			},
			&ebpf.Exit{}, // exit
		}),
	}

	// All maps loaded from elf files are BPFGenericMaps
	statsMap := program.Maps["xdp_stats_map"].(*gobpfld.BPFGenericMap)

	log, err := program.Load(gobpfld.BPFProgramLoadSettings{
		ProgramType:      bpftypes.BPF_PROG_TYPE_XDP,
		VerifierLogLevel: bpftypes.BPFLogLevelBasic,
	})

	fmt.Printf("BPF Verifier log:\n%s\n", log)

	if err != nil {
		program.DecodeToReader(os.Stdout)
		fmt.Fprintf(os.Stderr, "error while loading program: %s\n", err.Error())
		os.Exit(1)
	}

	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, unix.SIGTERM, unix.SIGINT)

	err = program.XDPLinkAttach(gobpfld.BPFProgramXDPLinkAttachSettings{
		InterfaceName: "lo",
		Replace:       true,
	})

	if err != nil {
		fmt.Fprintf(os.Stderr, "error while attaching program to loopback device: %s\n", err.Error())
		os.Exit(1)
	}

	ticker := time.Tick(1 * time.Second)
	for {
		select {
		case <-ticker:
			// The key is 2 since the program puts stats in the XDP_PASS key which has value 2
			// Tho this is specific to the XDP program we are using as an example.
			key := uint32(2)
			var value int64

			err = statsMap.Get(&key, &value)
			if err != nil {
				fmt.Fprintf(os.Stderr, "error while getting stats from map: %s\n", err.Error())
				os.Exit(1)
			}

			fmt.Printf("%d packets were processed\n", value)

		case <-sigChan:
			fmt.Println("Detaching XPD program and stopping")

			err = program.XDPLinkDetach(gobpfld.BPFProgramXDPLinkDetachSettings{
				All: true,
			})
			if err != nil {
				fmt.Fprintf(os.Stderr, "error while detaching program: %s\n", err.Error())
				os.Exit(1)
			}

			os.Exit(0)
		}
	}
}
