package main

import (
	"fmt"
	"os"
	"os/signal"
	"strings"
	"time"

	"github.com/dylandreimerink/gobpfld"
	"github.com/dylandreimerink/gobpfld/bpftypes"
	"github.com/dylandreimerink/gobpfld/ebpf"
	"golang.org/x/sys/unix"
)

// This example command executes the same program as xdp_stats which is basic03-map-counter from
// xdp-tutorial. https://github.com/xdp-project/xdp-tutorial/tree/master/basic03-map-counter
// However, this example demonstrates manually recreating the program from eBPF assembly which
// have been annotated as a bonus lesson. The assembly is then assembled into
// eBPF instructions.
// The same output can be generated by a program using gobpflb to generate dynamic eBPF programs

func main() {
	program := &gobpfld.BPFProgram{
		Name:    gobpfld.MustNewObjName("xdp_stats1"),
		License: "GPL",
		Maps: map[string]gobpfld.BPFMap{
			"xdp_stats_map": &gobpfld.ArrayMap{
				AbstractMap: gobpfld.AbstractMap{
					Name: gobpfld.MustNewObjName("xdp_stats_map"),
					Definition: gobpfld.BPFMapDef{
						Type:       bpftypes.BPF_MAP_TYPE_ARRAY,
						KeySize:    4, // SizeOf(uint32)
						ValueSize:  8, // SizeOf(uint64)
						MaxEntries: 5,
					},
				},
			},
		},
		MapFDLocations: map[string][]uint64{
			"xdp_stats_map": {
				// `r1 = 0 ll` is the 5th instruction in this program. So the first byte of the
				// 5th instruction is the width of a instruction * 4 to skip the first 4 instructions
				uint64(ebpf.BPFInstSize) * 4,
			},
		},
	}

	asm := `
		# __u32 key = XDP_PASS;
 		r1 = 2
		*(u32 *)(r10 - 4) = r1

		# rec = bpf_map_lookup_elem(&xdp_stats_map, &key);
		r2 = r10
		r2 += -4
		r1 = 0 ll
		call 1
		
		# if (!rec) return XDP_ABORTED;
		r1 = 0
		if r0 == 0 goto return

		# lock_xadd(&rec->rx_packets, 1);
		r1 = 1
		lock *(u64 *)(r0 + 0) += r1

		# return XDP_PASS;
		r1 = 2

	return:
		r0 = r1
		exit		
	`

	inst, err := ebpf.AssemblyToInstructions("inline-asm", strings.NewReader(asm))
	if err != nil {
		panic(err)
	}

	program.Instructions = ebpf.MustEncode(inst)

	// All maps loaded from elf files are BPFGenericMaps
	statsMap := program.Maps["xdp_stats_map"].(*gobpfld.ArrayMap)

	log, err := program.Load(gobpfld.BPFProgramLoadSettings{
		ProgramType:      bpftypes.BPF_PROG_TYPE_XDP,
		VerifierLogLevel: bpftypes.BPFLogLevelBasic,
	})

	fmt.Printf("BPF Verifier log:\n%s\n", log)

	if err != nil {
		program.DecodeToReader(os.Stdout)
		fmt.Fprintf(os.Stderr, "error while loading program: %s\n", err.Error())
		os.Exit(1)
	}

	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, unix.SIGTERM, unix.SIGINT)

	err = program.XDPLinkAttach(gobpfld.BPFProgramXDPLinkAttachSettings{
		InterfaceName: "lo",
		Replace:       true,
	})

	if err != nil {
		fmt.Fprintf(os.Stderr, "error while attaching program to loopback device: %s\n", err.Error())
		os.Exit(1)
	}

	ticker := time.Tick(1 * time.Second)
	for {
		select {
		case <-ticker:
			// The key is 2 since the program puts stats in the XDP_PASS key which has value 2
			// Tho this is specific to the XDP program we are using as an example.
			key := uint32(2)
			var value int64

			err = statsMap.Get(key, &value)
			if err != nil {
				fmt.Fprintf(os.Stderr, "error while getting stats from map: %s\n", err.Error())
				os.Exit(1)
			}

			fmt.Printf("%d packets were processed\n", value)

		case <-sigChan:
			fmt.Println("Detaching XPD program and stopping")

			err = program.XDPLinkDetach(gobpfld.BPFProgramXDPLinkDetachSettings{
				All: true,
			})
			if err != nil {
				fmt.Fprintf(os.Stderr, "error while detaching program: %s\n", err.Error())
				os.Exit(1)
			}

			os.Exit(0)
		}
	}
}
